\chapter{Аналитический раздел}

\section{Постановка задачи}

В рамках выполнения курсовой работы необходимо решить следующие \textbf{задачи}:
\begin{itemize}
	\item формализовать задание в виде определения необходимого функционала;
	\item провести анализ методов реализации;
	\item спроектировать программное обеспечение;
	\item реализовать спроектированное программное обеспечение.
\end{itemize}

\section{Формализация задания}

В соответствии с техническим заданием на курсовую работу необходимо разработать программное обеспечение, которое добавляет проверку наличия подключённого через интерфейс USB flash-накопителя с заданным серийным номером в процесс загрузки операционной системы Linux.

Ограничение: использование ПК подразумевается одним пользователем с единственным usb-ключём.

\section{Анализ методов реализации}

\begin{itemize}
	\item PAM
	\item LUKS
	\item Патч ядра
	\item Загружаемый модуль ядра
\end{itemize}

\subsection{PAM}

PAM (\textbf{P}luggable \textbf{A}uthentication \textbf{M}odules, \textit{рус.} \textbf{П}одключаемые \textbf{М}одули \textbf{А}утентификации, ПМА) — это набор разделяемых библиотек, позволяющих разрабатывать программы, не зависящие от схемы аутентификации.

На заре UNIX аутентификация пользователя выполнялась следующим образом: программа \code{login} требовала ввести имя и пароль, затем этот пароль шифровался известным алгоритмом и сравнивался с соответствующей зашифрованной записью в файле \code{/etc/passwd}.

Впоследствии программа \code{login} была переписана, т. к. зашифрованный пароль перестал открыто храниться в \code{/etc/passwd}, и был перемещён в отдельный файл скрытых паролей \code{/etc/shadow}, доступный для чтения только суперпользователю.

Появлялись новые схемы аутентификации, и проблема заключалась в том, что каждый раз приходилось переписывать все необходимые программы (\code{login}, \code{dtlogin}, \code{rlogin}, \code{ftp}, \code{rsh}, \code{telnet}, \ldots).

Для отделения программ от механизма аутентификации в октябре 1995 года инженерами американской компании Sun Microsystems был предложен PAM \cite{rfc-86.0}. Впервые же PAM появился в августе 1996 года в Red Hat Linux 3.0.4 (Rembrand II) \cite{red-hat-linux-3.0.4}.

Конфигурационные файлы PAM для различных приложений располагаются в директории \code{/etc/pam.d/}.
Имя каждого конфигурационного файла в этой директории совпадает с именем программы, для которого он предназначен.

Конфигурационные файлы описывают стек модулей.
Дескриптор модуля имеет формат:
\begin{verbatim}
	<Тип-Модуля> <Флаг-Управления> <Путь-К-Модулю> [Параметры-Модуля]
\end{verbatim}

\code{Тип-Модуля} может быть одним из четырёх, перечисленных ниже:
\begin{itemize}
	\item \code{auth} — модули аутентификации.
	Предназначены для аутентификации и идентификации пользователей, а также создания, обновления и уничтожения учётных данных.
	\item \code{account} — модули учётных записей.
	Предназначены для проверки срока действия паролей, учётных записей и ограничения времени доступа.
	После того, как пользователь идентифицирован с помощью модулей аутентификации, модули учетных записей определяют, следует ли предоставить пользователю доступ.
	\item \code{session} — модули сеансов.
	Предназначены для управления выполнением задач во время начала и окончания сессии аутентификации.
	\item \code{password} — модули паролей.
	Предназначены для изменения паролей.
\end{itemize}

\code{Флаг-Управления} определяет дальнейший порядок исполнения стека при удачном или неудачном прохождении соответствующего модуля.
Наиболее распространённые флаги управления:
\begin{itemize}
	\item \code{required} — модуль должен завершиться успешно.
	В случае неудачи статус ошибки будет возвращён после исполнения оставшихся модулей.
	\item \code{requisite} — модуль должен завершиться успешно.
	В случае неудачи статус ошибки будет возвращён сразу.
	\item \code{sufficient} — успешное завершение модуля возвращает статус \code{PAM\_SUCCESS} сразу.
	Неудача не препятствует успешному исполнению стека.
	\item \code{optional} — не оказывает влияния на статус исполнения стека.
\end{itemize}

Проверку серийного номера подключённого USB-устройства необходимо реализовать в виде отдельного PAM модуля, дескриптор которого с флагом управления \code{requisite} поместить в конфигурационный файл \code{/etc/pam.d/login} перед непосредственной проверкой пароля.

\subsection{LUKS}

LUKS (\textbf{L}inux \textbf{U}nified \textbf{K}ey \textbf{S}etup) — это спецификация форматов шифрования дисков, предназначенная для Linux, созданная Клеменсом Фрувиртом в 2005 году \cite{fruhwirth}.

В то время как большая часть программного обеспечения для шифрования дисков реализует различные, несовместимые и недокументированные форматы, LUKS реализует платформенно-независимый стандартный дисковый формат для использования в различных инструментах.
Это не только облегчает совместимость и взаимодействие между различными программами, но также гарантирует, что все они реализуют управление паролями безопасным и документированным способом.

Для реализации двухфакторной аутентификации с использованием LUKS можно зашифровать раздел диска с помощью файла-ключа, помещённого на USB-накопитель и содержащего либо сам серийный номер, либо хеш от него.

\subsection{Патч ядра}

Один из способов реализации поставленной задачи заключается в изменении кода ядра непосредственно.

Для того, чтобы добавить патч, необходимо найти правильное место в ядре для вставки кода.

При подключении устройства через интерфейс USB, в системном журнале появляются сообщения вида:
\verbatimfont{\footnotesize}
\begin{verbatim}
	New USB device found, idVendor=%04x, idProduct=%04x, bcdDevice=%2x.%02x
	New USB device strings: Mfr=%d, Product=%d, SerialNumber=%d
\end{verbatim}

Путём поиска в исходном коде ядра, находим функцию, которая производит записи такого формата в системный журнал:
\verbatimfont{\small}
\begin{verbatim}
	/* inside drivers/usb/core/hub.c */
	static void announce_device(struct usb_device *udev);
\end{verbatim}

Так как функция \code{announce\_device}\footnote{\url{https://elixir.bootlin.com/linux/v5.9.14/source/drivers/usb/core/hub.c\#L2271}} является лишь обёрткой для записи в системный журнал, необходимо проанализировать функции, которые её вызывают.

Вызов функции \code{announce\_device} происходит в единственном месте — в функции \code{usb\_new\_device}\footnote{\url{https://elixir.bootlin.com/linux/v5.9.14/source/drivers/usb/core/hub.c\#L2500}}:
\begin{verbatim}
	/* inside drivers/usb/core/hub.c */
	int usb_new_device(struct usb_device *udev);
\end{verbatim}

Описание функции ядра \code{usb\_new\_device} свидетельствует о том, что именно она вызывается при подключении USB-устройства, следовательно, проверку серийного номера необходимо добавить в эту функцию.

\subsection{Загружаемый модуль ядра}

Загружаемый модуль ядра (\textit{англ.} \textbf{L}oadable \textbf{K}ernel \textbf{M}odule, LKM) — это объектный файл, содержащий код, расширяющий возможности ядра операционной системы.

Загружаемые модули позволяют вносить изменения в код ядра без его перекомпиляции.
При этом в распоряжении разработчика оказываются все имеющиеся ядрёные библиотеки.

Для реализации поставленной задачи необходимо зарегистрировать собственный USB-драйвер, а именно:
\begin{itemize}
	\item заполнить дескриптора драйвера — структуру \code{usb\_driver};
	\item непосредственно зарегистрировать структуру в системе с помощью функции \code{usb\_register} \cite{ubs-driver}.
\end{itemize}

Рассмотрим наиболее важные поля структуры \code{usb\_driver} (листинг \ref{lst:usb-driver}).

\begin{lstlisting}[
	basicstyle=\small\ttfamily,
	numberstyle=\footnotesize\ttfamily\color{gray},
	caption={\code{struct usb\_driver}\label{lst:usb-driver}},
	gobble=8,
	language=C
]
	#include <linux/usb.h>

	struct usb_driver {
		const char *name;

		int (*probe) (struct usb_interface *intf,
		              const struct usb_device_id *id);

		void (*disconnect) (struct usb_interface *intf);

		const struct usb_device_id *id_table;

		// ...
	};
\end{lstlisting}

\begin{itemize}
	\item \code{name} — имя драйвера.
	Должно быть уникальным среди драйверов USB.
	Обычно совпадает с именем модуля.
	\item \code{id\_table} — это массив структур \code{usb\_device\_id}.
	Определяет список устройств, при подключении которых вызывается код драйвера.
	Массив заканчивается терминирующей пустой структурой.
	В случае отсутствия в массиве структур, система будет пытаться подключить каждое устройство к драйверу.
	\item \code{probe} и \code{disconnect} — это callback-функции, которые вызываются системой при подключении и отключении USB-устройства.
\end{itemize}

Таким образом, проверку серийного номера подключённого USB-устройства необходимо произвести в функции \code{probe} разрабатываемого модуля ядра.

\subsection{Выбор метода реализации}

Наиболее правильным было бы использовать PAM, т. к. именно для решения задач, связанных с аутентификацией, они и создавались.

Однако использование готовых инструментов, таких как PAM или LUKS, в меньшей степени способствует приобретению практических навыков реализации задач системного программирования.

В связи с этим, в качестве метода из двух оставшихся выбрана разработка загружаемого модуля, поскольку патч ядра уместен лишь в случае невозможности решения задач средствами lkm.

\section*{Вывод}

В результате проведённого анализа методов реализации аутентификации ОС Linux с помощью USB-ключа была выбрана разработка загружаемого модуля ядра.