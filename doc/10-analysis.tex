\chapter{Аналитический раздел}

\section{Постановка задачи}

\textbf{Целью} курсовой работы является добавление шага аутентификации с помощью USB-ключа в ОС Linux.

В рамках выполнения курсовой работы необходимо решить следующие \textbf{задачи}:
\begin{itemize}
	\item формализовать задание в виде определения необходимого функционала;
	\item провести анализ методов реализации;
	\item спроектировать программное обеспечение;
	\item реализовать спроектированное программное обеспечение;
\end{itemize}

\section{Формализация задания}

В соответствии с техническим заданием на курсовую работу необходимо разработать программное обеспечение, которое добавляет в процесс загрузки операционной системы Linux проверку наличия подключённого через интерфейс USB flash-накопителя с заданным серийным номером.

Ограничение: использование ПК подразумевается одним пользователем с единственным или, возможно, несколькими usb-ключами.

\section{Анализ методов реализации}

\begin{itemize}
	\item PAM
	\item LUKS
	\item Патч ядра
	\item Загружаемый модуль ядра
\end{itemize}

\section{PAM}

PAM (\textbf{P}luggable \textbf{A}uthentication \textbf{M}odules, \textit{рус.} \textbf{П}одключаемые \textbf{М}одули \textbf{А}утентификации, ПМА) — это набор разделяемых библиотек, позволяющих разрабатывать программы, не зависящие от схемы аутентификации.

На заре UNIX аутентификация пользователя выполнялась следующим образом: программа \code{login} требовала ввести имя и пароль, затем этот пароль шифровался известным алгоритмом и сравнивался с соответствующей зашифрованной записью в файле \code{/etc/passwd}.

Впоследствии программа \code{login} была переписана, т. к. зашифрованный пароль перестал открыто храниться в \code{/etc/passwd}, и был перемещён в отдельный файл скрытых паролей \code{/etc/shadow}, доступный для чтения только суперпользователю.

Появлялись новые схемы аутентификации, и проблема заключалась в том, что каждый раз приходилось переписывать все необходимые программы (\code{login}, \code{dtlogin}, \code{rlogin}, \code{ftp}, \code{rsh}, \code{telnet}, \ldots).

Для отделения программ от механизма аутентификации в октябре 1995 года инженерами американской компании Sun Microsystems был предложен PAM \cite{rfc-86.0}. Впервые же PAM появился в августе 1996 года в Red Hat Linux 3.0.4 (Rembrand II) \cite{red-hat-linux-3.0.4}.

Конфигурационные файлы PAM для различных приложений располагаются в директории \code{/etc/pam.d/}.
Имя каждого конфигурационного файла в этой директории совпадает с именем программы, для которого он предназначен.

Конфигурационные файлы описывают стек модулей.
Дескриптор модуля имеет формат:
\begin{verbatim}
	<Тип-Модуля> <Флаг-Управления> <Путь-К-Модулю> [Параметры-Модуля]
\end{verbatim}

\code{Тип-Модуля} может быть одним из четырёх, перечисленных ниже:
\begin{itemize}
	\item \code{auth} — модули аутентификации.
	Предназначены для аутентификации и идентификации пользователей, а также создания, обновления и уничтожения учётных данных.
	\item \code{account} — модули учётных записей.
	Предназначены для проверки срока действия паролей, учётных записей и ограничения времени доступа.
	После того, как пользователь идентифицирован с помощью модулей аутентификации, модули учетных записей определяют, следует ли предоставить пользователю доступ.
	\item \code{session} — модули сеансов.
	Предназначены для управления выполнением задач во время начала и окончания сессии аутентификации.
	\item \code{password} — модули паролей.
	Предназначены для изменения паролей.
\end{itemize}

\code{Флаг-Управления} определяет дальнейший порядок исполнения стека при удачном или неудачном прохождении соответствующего модуля.
Наиболее распространённые флаги управления:
\begin{itemize}
	\item \code{required} — модуль должен завершиться успешно.
	В случае неудачи статус ошибки будет возвращён после исполнения оставшихся модулей.
	\item \code{requisite} — модуль должен завершиться успешно.
	В случае неудачи статус ошибки будет возвращён сразу.
	\item \code{sufficient} — успешное завершение модуля возвращает статус \code{PAM\_SUCCESS} сразу.
	Неудача не препятствует успешному исполнению стека.
	\item \code{optional} — не оказывает влияния на статус исполнения стека.
\end{itemize}

Проверку серийного номера подключённого USB-устройства необходимо реализовать в виде отдельного PAM модуля, дескриптор которого с флагом управления \code{requisite} поместить в конфигурационный файл \code{/etc/pam.d/login} перед непосредственной проверкой пароля.

\section{LUKS}

LUKS (\textbf{L}inux \textbf{U}nified \textbf{K}ey \textbf{S}etup) — это спецификация форматов шифрования дисков, предназначенная для Linux, созданная Клеменсом Фрувиртом в 2005 году \cite{fruhwirth}.

В то время как большая часть программного обеспечения для шифрования дисков реализует различные, несовместимые и недокументированные форматы, LUKS реализует платформенно-независимый стандартный дисковый формат для использования в различных инструментах.
Это не только облегчает совместимость и взаимодействие между различными программами, но также гарантирует, что все они реализуют управление паролями безопасным и документированным способом.

Для реализации двухфакторной аутентификации с использованием LUKS можно зашифровать раздел диска с помощью файла-ключа, помещённого на USB-накопитель и содержащего либо сам серийный номер, либо хеш от него.

\section{Патч ядра}

Для того, чтобы добавить патч, необходимо найти правильное место в ядре для вставки кода.

При подключении устройства через интерфейс USB, в системном журнале появляются сообщения вида:
\verbatimfont{\footnotesize}
\begin{verbatim}
	New USB device found, idVendor=%04x, idProduct=%04x, bcdDevice=%2x.%02x
	New USB device strings: Mfr=%d, Product=%d, SerialNumber=%d
\end{verbatim}

Путём поиска в исходном коде ядра, находим функцию, которая производит записи такого формата в системный журнал:
\verbatimfont{\small}
\begin{verbatim}
	/* inside drivers/usb/core/hub.c */
	static void announce_device(struct usb_device *udev);
\end{verbatim}

Так как функция \code{announce\_device}\footnote{\url{https://elixir.bootlin.com/linux/v5.9.14/source/drivers/usb/core/hub.c\#L2271}} является лишь обёрткой для записи в системный журнал, необходимо проанализировать функции, которые её вызывают.

Вызов функции \code{announce\_device} происходит в единственном месте — в функции \code{usb\_new\_device}\footnote{\url{https://elixir.bootlin.com/linux/v5.9.14/source/drivers/usb/core/hub.c\#L2500}}:
\begin{verbatim}
	/* inside drivers/usb/core/hub.c */
	int usb_new_device(struct usb_device *udev);
\end{verbatim}

Описание функции ядра \code{usb\_new\_device} свидетельствует о том, что именно она вызывается при подключении USB-устройства, следовательно, проверку серийного номера необходимо добавить в эту функцию.

\section{Загружаемый модуль ядра}

\section{}

% Наиболее правильным было бы использовать PAM, но так как задача стоит в разработке загружаемого модуля ядра, а цель — приобретения практических навыков реализации задач системного программирования, то выбран метод ручного вмешательства в процесс загрузки ОС.

\section*{Вывод}
